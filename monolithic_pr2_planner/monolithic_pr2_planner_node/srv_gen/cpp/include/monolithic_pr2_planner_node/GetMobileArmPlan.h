/* Auto-generated by genmsg_cpp for file /home/fahad/catkin_ws/src/monolithic_pr2_planner/monolithic_pr2_planner_node/srv/GetMobileArmPlan.srv */
#ifndef MONOLITHIC_PR2_PLANNER_NODE_SERVICE_GETMOBILEARMPLAN_H
#define MONOLITHIC_PR2_PLANNER_NODE_SERVICE_GETMOBILEARMPLAN_H
#include <string>
#include <vector>
#include <map>
#include <ostream>
#include "ros/serialization.h"
#include "ros/builtin_message_traits.h"
#include "ros/message_operations.h"
#include "ros/time.h"

#include "ros/macros.h"

#include "ros/assert.h"

#include "ros/service_traits.h"

#include "geometry_msgs/PoseStamped.h"
#include "geometry_msgs/PoseStamped.h"
#include "geometry_msgs/PoseStamped.h"
#include "geometry_msgs/PoseStamped.h"


#include "trajectory_msgs/JointTrajectory.h"
#include "trajectory_msgs/JointTrajectory.h"

namespace monolithic_pr2_planner_node
{
template <class ContainerAllocator>
struct GetMobileArmPlanRequest_ {
  typedef GetMobileArmPlanRequest_<ContainerAllocator> Type;

  GetMobileArmPlanRequest_()
  : start()
  , underspecified_start(false)
  , planning_mode(0)
  , allocated_planning_time(0.0)
  , rarm_start()
  , larm_start()
  , body_start()
  , rarm_goal()
  , larm_goal()
  , body_goal()
  , goal()
  , xyz_tolerance(0.0)
  , roll_tolerance(0.0)
  , pitch_tolerance(0.0)
  , yaw_tolerance(0.0)
  , rarm_object()
  , larm_object()
  , initial_eps(0.0)
  , final_eps(0.0)
  , dec_eps(0.0)
  , planner_type(0)
  , meta_search_type(0)
  , use_ompl(false)
  {
  }

  GetMobileArmPlanRequest_(const ContainerAllocator& _alloc)
  : start(_alloc)
  , underspecified_start(false)
  , planning_mode(0)
  , allocated_planning_time(0.0)
  , rarm_start(_alloc)
  , larm_start(_alloc)
  , body_start(_alloc)
  , rarm_goal(_alloc)
  , larm_goal(_alloc)
  , body_goal(_alloc)
  , goal(_alloc)
  , xyz_tolerance(0.0)
  , roll_tolerance(0.0)
  , pitch_tolerance(0.0)
  , yaw_tolerance(0.0)
  , rarm_object(_alloc)
  , larm_object(_alloc)
  , initial_eps(0.0)
  , final_eps(0.0)
  , dec_eps(0.0)
  , planner_type(0)
  , meta_search_type(0)
  , use_ompl(false)
  {
  }

  typedef  ::geometry_msgs::PoseStamped_<ContainerAllocator>  _start_type;
   ::geometry_msgs::PoseStamped_<ContainerAllocator>  start;

  typedef uint8_t _underspecified_start_type;
  uint8_t underspecified_start;

  typedef int8_t _planning_mode_type;
  int8_t planning_mode;

  typedef double _allocated_planning_time_type;
  double allocated_planning_time;

  typedef std::vector<double, typename ContainerAllocator::template rebind<double>::other >  _rarm_start_type;
  std::vector<double, typename ContainerAllocator::template rebind<double>::other >  rarm_start;

  typedef std::vector<double, typename ContainerAllocator::template rebind<double>::other >  _larm_start_type;
  std::vector<double, typename ContainerAllocator::template rebind<double>::other >  larm_start;

  typedef std::vector<double, typename ContainerAllocator::template rebind<double>::other >  _body_start_type;
  std::vector<double, typename ContainerAllocator::template rebind<double>::other >  body_start;

  typedef std::vector<double, typename ContainerAllocator::template rebind<double>::other >  _rarm_goal_type;
  std::vector<double, typename ContainerAllocator::template rebind<double>::other >  rarm_goal;

  typedef std::vector<double, typename ContainerAllocator::template rebind<double>::other >  _larm_goal_type;
  std::vector<double, typename ContainerAllocator::template rebind<double>::other >  larm_goal;

  typedef std::vector<double, typename ContainerAllocator::template rebind<double>::other >  _body_goal_type;
  std::vector<double, typename ContainerAllocator::template rebind<double>::other >  body_goal;

  typedef  ::geometry_msgs::PoseStamped_<ContainerAllocator>  _goal_type;
   ::geometry_msgs::PoseStamped_<ContainerAllocator>  goal;

  typedef double _xyz_tolerance_type;
  double xyz_tolerance;

  typedef double _roll_tolerance_type;
  double roll_tolerance;

  typedef double _pitch_tolerance_type;
  double pitch_tolerance;

  typedef double _yaw_tolerance_type;
  double yaw_tolerance;

  typedef  ::geometry_msgs::PoseStamped_<ContainerAllocator>  _rarm_object_type;
   ::geometry_msgs::PoseStamped_<ContainerAllocator>  rarm_object;

  typedef  ::geometry_msgs::PoseStamped_<ContainerAllocator>  _larm_object_type;
   ::geometry_msgs::PoseStamped_<ContainerAllocator>  larm_object;

  typedef double _initial_eps_type;
  double initial_eps;

  typedef double _final_eps_type;
  double final_eps;

  typedef double _dec_eps_type;
  double dec_eps;

  typedef int8_t _planner_type_type;
  int8_t planner_type;

  typedef int8_t _meta_search_type_type;
  int8_t meta_search_type;

  typedef uint8_t _use_ompl_type;
  uint8_t use_ompl;


  typedef boost::shared_ptr< ::monolithic_pr2_planner_node::GetMobileArmPlanRequest_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::monolithic_pr2_planner_node::GetMobileArmPlanRequest_<ContainerAllocator>  const> ConstPtr;
  boost::shared_ptr<std::map<std::string, std::string> > __connection_header;
}; // struct GetMobileArmPlanRequest
typedef  ::monolithic_pr2_planner_node::GetMobileArmPlanRequest_<std::allocator<void> > GetMobileArmPlanRequest;

typedef boost::shared_ptr< ::monolithic_pr2_planner_node::GetMobileArmPlanRequest> GetMobileArmPlanRequestPtr;
typedef boost::shared_ptr< ::monolithic_pr2_planner_node::GetMobileArmPlanRequest const> GetMobileArmPlanRequestConstPtr;



template <class ContainerAllocator>
struct GetMobileArmPlanResponse_ {
  typedef GetMobileArmPlanResponse_<ContainerAllocator> Type;

  GetMobileArmPlanResponse_()
  : trajectory()
  , body_trajectory()
  , stats_field_names()
  , stats()
  {
  }

  GetMobileArmPlanResponse_(const ContainerAllocator& _alloc)
  : trajectory(_alloc)
  , body_trajectory(_alloc)
  , stats_field_names(_alloc)
  , stats(_alloc)
  {
  }

  typedef  ::trajectory_msgs::JointTrajectory_<ContainerAllocator>  _trajectory_type;
   ::trajectory_msgs::JointTrajectory_<ContainerAllocator>  trajectory;

  typedef  ::trajectory_msgs::JointTrajectory_<ContainerAllocator>  _body_trajectory_type;
   ::trajectory_msgs::JointTrajectory_<ContainerAllocator>  body_trajectory;

  typedef std::vector<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > , typename ContainerAllocator::template rebind<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > >::other >  _stats_field_names_type;
  std::vector<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > , typename ContainerAllocator::template rebind<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > >::other >  stats_field_names;

  typedef std::vector<double, typename ContainerAllocator::template rebind<double>::other >  _stats_type;
  std::vector<double, typename ContainerAllocator::template rebind<double>::other >  stats;


  typedef boost::shared_ptr< ::monolithic_pr2_planner_node::GetMobileArmPlanResponse_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::monolithic_pr2_planner_node::GetMobileArmPlanResponse_<ContainerAllocator>  const> ConstPtr;
  boost::shared_ptr<std::map<std::string, std::string> > __connection_header;
}; // struct GetMobileArmPlanResponse
typedef  ::monolithic_pr2_planner_node::GetMobileArmPlanResponse_<std::allocator<void> > GetMobileArmPlanResponse;

typedef boost::shared_ptr< ::monolithic_pr2_planner_node::GetMobileArmPlanResponse> GetMobileArmPlanResponsePtr;
typedef boost::shared_ptr< ::monolithic_pr2_planner_node::GetMobileArmPlanResponse const> GetMobileArmPlanResponseConstPtr;


struct GetMobileArmPlan
{

typedef GetMobileArmPlanRequest Request;
typedef GetMobileArmPlanResponse Response;
Request request;
Response response;

typedef Request RequestType;
typedef Response ResponseType;
}; // struct GetMobileArmPlan
} // namespace monolithic_pr2_planner_node

namespace ros
{
namespace message_traits
{
template<class ContainerAllocator> struct IsMessage< ::monolithic_pr2_planner_node::GetMobileArmPlanRequest_<ContainerAllocator> > : public TrueType {};
template<class ContainerAllocator> struct IsMessage< ::monolithic_pr2_planner_node::GetMobileArmPlanRequest_<ContainerAllocator>  const> : public TrueType {};
template<class ContainerAllocator>
struct MD5Sum< ::monolithic_pr2_planner_node::GetMobileArmPlanRequest_<ContainerAllocator> > {
  static const char* value() 
  {
    return "678990028373baa14adc6c690d46ac3d";
  }

  static const char* value(const  ::monolithic_pr2_planner_node::GetMobileArmPlanRequest_<ContainerAllocator> &) { return value(); } 
  static const uint64_t static_value1 = 0x678990028373baa1ULL;
  static const uint64_t static_value2 = 0x4adc6c690d46ac3dULL;
};

template<class ContainerAllocator>
struct DataType< ::monolithic_pr2_planner_node::GetMobileArmPlanRequest_<ContainerAllocator> > {
  static const char* value() 
  {
    return "monolithic_pr2_planner_node/GetMobileArmPlanRequest";
  }

  static const char* value(const  ::monolithic_pr2_planner_node::GetMobileArmPlanRequest_<ContainerAllocator> &) { return value(); } 
};

template<class ContainerAllocator>
struct Definition< ::monolithic_pr2_planner_node::GetMobileArmPlanRequest_<ContainerAllocator> > {
  static const char* value() 
  {
    return "\n\
geometry_msgs/PoseStamped start\n\
\n\
bool underspecified_start\n\
int8 planning_mode\n\
float64 allocated_planning_time\n\
\n\
float64[] rarm_start\n\
float64[] larm_start\n\
float64[] body_start\n\
float64[] rarm_goal\n\
float64[] larm_goal\n\
float64[] body_goal\n\
\n\
geometry_msgs/PoseStamped goal\n\
\n\
float64 xyz_tolerance\n\
float64 roll_tolerance\n\
float64 pitch_tolerance\n\
float64 yaw_tolerance\n\
\n\
geometry_msgs/PoseStamped rarm_object\n\
\n\
geometry_msgs/PoseStamped larm_object\n\
float64 initial_eps\n\
float64 final_eps\n\
float64 dec_eps\n\
int8 planner_type\n\
int8 meta_search_type\n\
bool use_ompl\n\
\n\
================================================================================\n\
MSG: geometry_msgs/PoseStamped\n\
# A Pose with reference coordinate frame and timestamp\n\
Header header\n\
Pose pose\n\
\n\
================================================================================\n\
MSG: std_msgs/Header\n\
# Standard metadata for higher-level stamped data types.\n\
# This is generally used to communicate timestamped data \n\
# in a particular coordinate frame.\n\
# \n\
# sequence ID: consecutively increasing ID \n\
uint32 seq\n\
#Two-integer timestamp that is expressed as:\n\
# * stamp.secs: seconds (stamp_secs) since epoch\n\
# * stamp.nsecs: nanoseconds since stamp_secs\n\
# time-handling sugar is provided by the client library\n\
time stamp\n\
#Frame this data is associated with\n\
# 0: no frame\n\
# 1: global frame\n\
string frame_id\n\
\n\
================================================================================\n\
MSG: geometry_msgs/Pose\n\
# A representation of pose in free space, composed of postion and orientation. \n\
Point position\n\
Quaternion orientation\n\
\n\
================================================================================\n\
MSG: geometry_msgs/Point\n\
# This contains the position of a point in free space\n\
float64 x\n\
float64 y\n\
float64 z\n\
\n\
================================================================================\n\
MSG: geometry_msgs/Quaternion\n\
# This represents an orientation in free space in quaternion form.\n\
\n\
float64 x\n\
float64 y\n\
float64 z\n\
float64 w\n\
\n\
";
  }

  static const char* value(const  ::monolithic_pr2_planner_node::GetMobileArmPlanRequest_<ContainerAllocator> &) { return value(); } 
};

} // namespace message_traits
} // namespace ros


namespace ros
{
namespace message_traits
{
template<class ContainerAllocator> struct IsMessage< ::monolithic_pr2_planner_node::GetMobileArmPlanResponse_<ContainerAllocator> > : public TrueType {};
template<class ContainerAllocator> struct IsMessage< ::monolithic_pr2_planner_node::GetMobileArmPlanResponse_<ContainerAllocator>  const> : public TrueType {};
template<class ContainerAllocator>
struct MD5Sum< ::monolithic_pr2_planner_node::GetMobileArmPlanResponse_<ContainerAllocator> > {
  static const char* value() 
  {
    return "772cf36670d0cc0bb947f449eafd6cce";
  }

  static const char* value(const  ::monolithic_pr2_planner_node::GetMobileArmPlanResponse_<ContainerAllocator> &) { return value(); } 
  static const uint64_t static_value1 = 0x772cf36670d0cc0bULL;
  static const uint64_t static_value2 = 0xb947f449eafd6cceULL;
};

template<class ContainerAllocator>
struct DataType< ::monolithic_pr2_planner_node::GetMobileArmPlanResponse_<ContainerAllocator> > {
  static const char* value() 
  {
    return "monolithic_pr2_planner_node/GetMobileArmPlanResponse";
  }

  static const char* value(const  ::monolithic_pr2_planner_node::GetMobileArmPlanResponse_<ContainerAllocator> &) { return value(); } 
};

template<class ContainerAllocator>
struct Definition< ::monolithic_pr2_planner_node::GetMobileArmPlanResponse_<ContainerAllocator> > {
  static const char* value() 
  {
    return "\n\
trajectory_msgs/JointTrajectory trajectory\n\
trajectory_msgs/JointTrajectory body_trajectory\n\
\n\
string[] stats_field_names\n\
float64[] stats\n\
\n\
\n\
================================================================================\n\
MSG: trajectory_msgs/JointTrajectory\n\
Header header\n\
string[] joint_names\n\
JointTrajectoryPoint[] points\n\
================================================================================\n\
MSG: std_msgs/Header\n\
# Standard metadata for higher-level stamped data types.\n\
# This is generally used to communicate timestamped data \n\
# in a particular coordinate frame.\n\
# \n\
# sequence ID: consecutively increasing ID \n\
uint32 seq\n\
#Two-integer timestamp that is expressed as:\n\
# * stamp.secs: seconds (stamp_secs) since epoch\n\
# * stamp.nsecs: nanoseconds since stamp_secs\n\
# time-handling sugar is provided by the client library\n\
time stamp\n\
#Frame this data is associated with\n\
# 0: no frame\n\
# 1: global frame\n\
string frame_id\n\
\n\
================================================================================\n\
MSG: trajectory_msgs/JointTrajectoryPoint\n\
float64[] positions\n\
float64[] velocities\n\
float64[] accelerations\n\
duration time_from_start\n\
";
  }

  static const char* value(const  ::monolithic_pr2_planner_node::GetMobileArmPlanResponse_<ContainerAllocator> &) { return value(); } 
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

template<class ContainerAllocator> struct Serializer< ::monolithic_pr2_planner_node::GetMobileArmPlanRequest_<ContainerAllocator> >
{
  template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
  {
    stream.next(m.start);
    stream.next(m.underspecified_start);
    stream.next(m.planning_mode);
    stream.next(m.allocated_planning_time);
    stream.next(m.rarm_start);
    stream.next(m.larm_start);
    stream.next(m.body_start);
    stream.next(m.rarm_goal);
    stream.next(m.larm_goal);
    stream.next(m.body_goal);
    stream.next(m.goal);
    stream.next(m.xyz_tolerance);
    stream.next(m.roll_tolerance);
    stream.next(m.pitch_tolerance);
    stream.next(m.yaw_tolerance);
    stream.next(m.rarm_object);
    stream.next(m.larm_object);
    stream.next(m.initial_eps);
    stream.next(m.final_eps);
    stream.next(m.dec_eps);
    stream.next(m.planner_type);
    stream.next(m.meta_search_type);
    stream.next(m.use_ompl);
  }

  ROS_DECLARE_ALLINONE_SERIALIZER;
}; // struct GetMobileArmPlanRequest_
} // namespace serialization
} // namespace ros


namespace ros
{
namespace serialization
{

template<class ContainerAllocator> struct Serializer< ::monolithic_pr2_planner_node::GetMobileArmPlanResponse_<ContainerAllocator> >
{
  template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
  {
    stream.next(m.trajectory);
    stream.next(m.body_trajectory);
    stream.next(m.stats_field_names);
    stream.next(m.stats);
  }

  ROS_DECLARE_ALLINONE_SERIALIZER;
}; // struct GetMobileArmPlanResponse_
} // namespace serialization
} // namespace ros

namespace ros
{
namespace service_traits
{
template<>
struct MD5Sum<monolithic_pr2_planner_node::GetMobileArmPlan> {
  static const char* value() 
  {
    return "ca80c20ca7a1caf76ab297b863eb4514";
  }

  static const char* value(const monolithic_pr2_planner_node::GetMobileArmPlan&) { return value(); } 
};

template<>
struct DataType<monolithic_pr2_planner_node::GetMobileArmPlan> {
  static const char* value() 
  {
    return "monolithic_pr2_planner_node/GetMobileArmPlan";
  }

  static const char* value(const monolithic_pr2_planner_node::GetMobileArmPlan&) { return value(); } 
};

template<class ContainerAllocator>
struct MD5Sum<monolithic_pr2_planner_node::GetMobileArmPlanRequest_<ContainerAllocator> > {
  static const char* value() 
  {
    return "ca80c20ca7a1caf76ab297b863eb4514";
  }

  static const char* value(const monolithic_pr2_planner_node::GetMobileArmPlanRequest_<ContainerAllocator> &) { return value(); } 
};

template<class ContainerAllocator>
struct DataType<monolithic_pr2_planner_node::GetMobileArmPlanRequest_<ContainerAllocator> > {
  static const char* value() 
  {
    return "monolithic_pr2_planner_node/GetMobileArmPlan";
  }

  static const char* value(const monolithic_pr2_planner_node::GetMobileArmPlanRequest_<ContainerAllocator> &) { return value(); } 
};

template<class ContainerAllocator>
struct MD5Sum<monolithic_pr2_planner_node::GetMobileArmPlanResponse_<ContainerAllocator> > {
  static const char* value() 
  {
    return "ca80c20ca7a1caf76ab297b863eb4514";
  }

  static const char* value(const monolithic_pr2_planner_node::GetMobileArmPlanResponse_<ContainerAllocator> &) { return value(); } 
};

template<class ContainerAllocator>
struct DataType<monolithic_pr2_planner_node::GetMobileArmPlanResponse_<ContainerAllocator> > {
  static const char* value() 
  {
    return "monolithic_pr2_planner_node/GetMobileArmPlan";
  }

  static const char* value(const monolithic_pr2_planner_node::GetMobileArmPlanResponse_<ContainerAllocator> &) { return value(); } 
};

} // namespace service_traits
} // namespace ros

#endif // MONOLITHIC_PR2_PLANNER_NODE_SERVICE_GETMOBILEARMPLAN_H

